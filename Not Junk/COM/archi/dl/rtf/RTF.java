package COM.archi.dl.rtf;

/* Generated By:JavaCC: Do not edit this line. RTF.java */
//package COM.archi.dl.rtf;

import java.awt.*;
import java.io.*;

public class RTF implements RTFConstants {
         //private RTFDestinationState destinationState;
         //private RTFInternalState internalState;
         //private int currentGroup = 0;

         //private CharacterProperties chp;
         //private ParagraphProperties pap;
         //private SectionProperties sep;
         //private DocumentProperties dop;

         public static void main(String args[]) throws ParseError
         {
         RTF parser = null;
         Frame frame = new Frame();
         FileDialog fd = new FileDialog( frame, "Select grammar file...", FileDialog.LOAD );
         fd.show();
         File file = new File( fd.getDirectory() + fd.getFile() );
         try
         {
                         FileInputStream fileInput = new FileInputStream( file );
                 parser = new RTF( fileInput );
                 }
                 catch ( FileNotFoundException e )
                 {}

         Token t = parser.getNextToken();

         while ( t.kind != RTFConstants.EOF )
         {
                 System.out.println( t.image + t.kind );
                 t = parser.getNextToken();
         }
         }

  public RTFTokenManager token_source;
  public Token token;
  private RTF jj_me;
  private int jj_gen;
  private int[] jj_expLA1 = new int[0];

  public RTF(java.io.InputStream stream) {
    ASCII_CharStream input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new RTFTokenManager(input_stream);
    token = new Token();
    jj_me = this;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_expLA1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    ASCII_CharStream input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source.ReInit(input_stream);
    token = new Token();
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_expLA1[i] = -1;
  }

  public RTF(RTFTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_me = this;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_expLA1[i] = -1;
  }

  public void ReInit(RTFTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_expLA1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseError {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    jj_token_error_setup(token, kind);
    throw new ParseError();
  }

  final public Token getNextToken() throws ParseError {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) throws ParseError {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final String jj_add_escapes(String str) {
    String retval = "";
    char ch;
    for (int i = 0; i < str.length(); i++) {
      ch = str.charAt(i);
      if (ch == '\b') {
        retval += "\\b";
      } else if (ch == '\t') {
        retval += "\\t";
      } else if (ch == '\n') {
        retval += "\\n";
      } else if (ch == '\f') {
        retval += "\\f";
      } else if (ch == '\r') {
        retval += "\\r";
      } else if (ch == '\"') {
        retval += "\\\"";
      } else if (ch == '\'') {
        retval += "\\\'";
      } else if (ch == '\\') {
        retval += "\\\\";
      } else if (ch < 0x20 || ch > 0x7e) {
        String s = "0000" + Integer.toString(ch, 16);
        retval += "\\u" + s.substring(s.length() - 4, s.length());
      } else {
        retval += ch;
      }
    }
    return retval;
  }

  protected int error_line;
  protected int error_column;
  protected String error_string;
  protected String[] expected_tokens;

  protected void token_error() {
    System.out.println("");
    System.out.println("Parse error at line " + error_line + ", column " + error_column + ".  Encountered:");
    System.out.println("    \"" + jj_add_escapes(error_string) + "\"");
    System.out.println("");
    if (expected_tokens.length == 1) {
      System.out.println("Was expecting:");
    } else {
      System.out.println("Was expecting one of:");
    }
    for (int i = 0; i < expected_tokens.length; i++) {
      System.out.println("    " + expected_tokens[i]);
    }
    System.out.println("");
  }

  private java.util.Vector jj_errortokens = new java.util.Vector();

  final private void jj_token_error_setup(Token current, int kind) throws ParseError {
    jj_errortokens.removeAllElements();
    boolean[] la1tokens = new boolean[66];
    boolean[] mask = null;
    for (int i = 0; i < 66; i++) {
      la1tokens[i] = false;
    }
    if (kind >= 0) la1tokens[kind] = true;
    for (int i = 0; i < 0; i++) {
      if (jj_expLA1[i] == jj_gen) {
        switch (i) {
        }
        for (int j = 0; j < 66; j++) {
          if (mask[j]) la1tokens[j] = true;
        }
      }
    }
    if (la1tokens[0]) {
      jj_errortokens.addElement(tokenImage[0] + " ");
    }
    for (int i = 1; i < 66; i++) {
      if (la1tokens[i]) {
        jj_errortokens.addElement(tokenImage[i] + " ...");
      }
    }
    expected_tokens = new String[jj_errortokens.size()];
    for (int i = 0; i < jj_errortokens.size(); i++) {
      expected_tokens[i] = (String)(jj_errortokens.elementAt(i));
    }
    error_line = current.beginLine;
    error_column = current.beginColumn;
    if (current.kind == 0) {
      error_string = tokenImage[0];
    } else {
      error_string = current.image;
    }
    jj_me.token_error();
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
