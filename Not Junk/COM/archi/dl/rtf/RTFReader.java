package COM.archi.dl.rtf;import java.awt.*;import java.io.*;import java.util.*;public class RTFReader{	private RTF parser = null;	private RTFDestinationState currentDestinationState = RTFDestinationState.NORMAL;	private Font currentFont = new Font( "Serif", Font.PLAIN, 12 ); 	private Color currentColor = new Color( 0, 0, 0 );	private int currentGroup = 0;	private int currentParagraphNumber = 0;	private Hashtable fontTable = new Hashtable( 20 );	private Vector colorTable = new Vector( 20, 10 );		//private CharacterProperties chp = new CharacterProperties();	//private ParagraphProperties pap = new ParagraphProperties();	//private SectionProperties sep = new SectionProperties();	//private DocumentProperties dop = new DocumentProperties();		private Vector savedStates = new Vector( 10, 5 );		private StyledDocument styledDoc = new StyledDocument();		public RTFReader( InputStream inStream )	{		parser = new RTF( inStream );	}		public synchronized StyledDocument parseRTF() throws ParseError, IOException	{		//System.out.println( "parsing!!!" );		Token t = parser.getNextToken();    			while ( t.kind != RTFConstants.EOF )		{			if ( currentGroup < 0 )				throw new StackUnderflowException();							switch ( t.kind )			{				case RTFConstants.GroupStart:					pushRTFState();					break;				case RTFConstants.GroupEnd:					popRTFState();					break;				case RTFConstants.SkipDest:					setSkipState();					break;				case RTFConstants.PlainText: 					processPlainText( t.image ); 					break; 				case RTFConstants.HexCharStart: 					processHexChar( parser.getNextToken() ); 					break; 				case RTFConstants.FontNumber: 					setFont( t.image ); 					break; 				case RTFConstants.FontSize: 					setFontSize( t.image ); 					break; 				case RTFConstants.Paragraph: 					newParagraph(); 					break; 				case RTFConstants.ParagraphReset: 					resetParagraph(); 					break; 				case RTFConstants.Plain: 					setPlainStyle(); 					break; 				case RTFConstants.Bold: 					setBold(); 					break; 				case RTFConstants.Italic: 					setItalic(); 					break; 				case RTFConstants.Color: 					setColor( t.image ); 					break; 				//case RTFConstants.LeftAligned: 				//	setLeftAligned(); 				//	break; 				//case RTFConstants.RightAligned: 				//	setRightAligned(); 				//	break; 				//case RTFConstants.Centered: 				//	setCentered(); 				//	break; 				//case RTFConstants.Justified: 				//	setJustified(); 				//	break; 				//case RTFConstants.FirstLineIndent: 				//	setFirstLineIndent( t.image ); 				//	break; 				//case RTFConstants.LeftIndent: 				//	setLeftIndent( t.image ); 				//	break; 				//case RTFConstants.RightIndent: 				//	setRightIndent( t.image ); 				//	break; 				//case RTFConstants.SpaceAbove: 				//	setSpaceAbove( t.image ); 				//	break; 				//case RTFConstants.SpaceBelow: 				//	setSpaceBelow( t.image ); 				//	break; 				//case RTFConstants.LineSpacing: 				//	setLineSpacing( t.image ); 				//	break; 				case RTFConstants.ColorTableStart: 					processColorTable(); 					break; 				case RTFConstants.FontTableStart: 					processFontTable(); 					break;			} // end switch (token kind)						t = parser.getNextToken();					} // end while loop				if ( currentGroup < 0 )		{			throw new StackUnderflowException();		}		else if ( currentGroup > 0 )		{			throw new UnmatchedBraceException();		}		else		{			// RTF parsed successfully, return our document			return styledDoc;		}	}		private void pushRTFState()  	{  		//System.out.println( "pushed state" );  		State savedState = new State( currentDestinationState, currentFont, currentColor );  		savedStates.addElement( savedState );  		currentGroup++;  	}  	  	private void popRTFState()  	{  		//System.out.println( "popped state" );  		State currentState = (State)savedStates.lastElement();  		savedStates.removeElement( currentState );  		  		currentDestinationState = currentState.getDestinationState();  		currentFont = currentState.getFont();    		currentColor = currentState.getColor();  		currentGroup--;  	}  	  	private void processColorTable()  	{		//System.out.println( "process color table" );		Token t = null;		try		{			t = parser.getNextToken();		}		catch ( ParseError e )		{}  		int redValue = 0;  		int greenValue = 0;  		int blueValue = 0;  		  		while ( t.kind != RTFConstants.ColorTableEnd )  		{  			while ( t.kind != RTFConstants.EndColor )  			{  				if ( t.kind == RTFConstants.Red )  				{  					try  					{  						redValue = Integer.valueOf( parser.getNextToken().image ).intValue();  					}  					catch ( ParseError e )  					{}  				}  				else if ( t.kind == RTFConstants.Green )  				{  					try  					{  						greenValue = Integer.valueOf( parser.getNextToken().image ).intValue();  					}  					catch ( ParseError e )  					{}  				}  				else if ( t.kind == RTFConstants.Blue )  				{  					try  					{  						blueValue = Integer.valueOf( parser.getNextToken().image ).intValue();  					}  					catch ( ParseError e )  					{}  				}  				try  				{  					t = parser.getNextToken();  				}  				catch ( ParseError e )  				{}  			}  			// add the current color to our table  			colorTable.addElement( new Color(redValue, greenValue, blueValue) );  			// and advance to the next color or the end of the table  			try  			{  				t = parser.getNextToken();  			}  			catch ( ParseError e )  			{}  		} // while  		  		// decrement the group state at the color table closing brace  		currentGroup--;  	}  	  	private void processFontTable()  	{  		//System.out.println( "process font table" );  		Token t = null;  		  		try  		{  			t= parser.getNextToken();  		}  		catch ( ParseError e )  		{}  		  		String fontNumber = "";  		String fontName = "";  		  		while ( t.kind != RTFConstants.FontTableEnd )  		{  			while ( t.kind != RTFConstants.FontEnd )  			{  				if ( t.kind == RTFConstants.FontTableNumber )  				{  					fontNumber = t.image;  				}  				else if ( t.kind == RTFConstants.FontName )  				{  					fontName = t.image;  					//System.out.println( "into font table: " + fontName );  				}  				  				try  				{  					t = parser.getNextToken();  				}  				catch ( ParseError e )  				{}  			}  			// store the font name and number in our hashtable  			fontTable.put( fontNumber, fontName );  			// go to the next font entry  			try  			{  				t = parser.getNextToken();  			}  			catch ( ParseError e )  			{}  		} // end while  		  		// decrement the group state at the font table closing brace  		currentGroup--;  	}  	  	private void processPlainText( String text )  	{  		//System.out.println( "process plain text" );  		if ( currentDestinationState != RTFDestinationState.SKIP )  		{  			StyledTextRun str = new StyledTextRun( currentParagraphNumber, text, currentFont, currentColor );  			styledDoc.addStyledTextRun( str );  		}  	}  	  	private void processHexChar( Token hexChar )  	{  		//System.out.println( "process hex char" );  		if ( currentDestinationState != RTFDestinationState.SKIP )  		{  			Character theChar = new Character( (char)Integer.parseInt("0x00" + hexChar.image) );  			StyledTextRun str = new StyledTextRun( currentParagraphNumber, theChar.toString(), currentFont, currentColor );  			styledDoc.addStyledTextRun( str );  		}  	}  	  	private void newParagraph()  	{		//System.out.println( "new para" );		currentParagraphNumber++;  	}  	  	public void resetParagraph()  	{		//System.out.println( "new reset para" );		currentParagraphNumber++;  		currentFont = new Font("SanSerif", Font.PLAIN, 12);  	}  	  	public void setFont( String fontNumber )  	{  		//System.out.println( "set font" );  		String fontName = (String)fontTable.get( fontNumber.trim() );  		if ( fontName.startsWith("Times") || fontName.startsWith("Courier") )  		{  			currentFont = new Font( "Serif", currentFont.getStyle(), currentFont.getSize() );  		}  		else if ( fontName.startsWith("Arial") || fontName.startsWith("Helvetica") )  		{  		  	currentFont = new Font( "SanSerif", currentFont.getStyle(), currentFont.getSize() );  		}  		else  		{  			currentFont = new Font( fontName, currentFont.getStyle(), currentFont.getSize() );  		}  	}  	  	public void setFontSize( String size )  	{  		//System.out.println( "set font size" );  		// remove the control part of the size "\fs"  		size = size.substring(3);  		size = size.trim();  		int intSize = new Integer( size ).intValue() / 2;  		currentFont = new Font( currentFont.getName(), currentFont.getStyle(), intSize );  	}  	  	public void setPlainStyle()  	{  		currentFont = new Font( currentFont.getName(), Font.PLAIN, currentFont.getSize() );  	}  	  	private void setSkipState()  	{  		//System.out.println( "skip state" );  		currentDestinationState = RTFDestinationState.SKIP;  	}  	  	public void setBold()  	{  		currentFont = new Font( currentFont.getName(), currentFont.getStyle() + Font.BOLD, currentFont.getSize() );  	}  	  	public void setItalic()  	{  		currentFont = new Font( currentFont.getName(), currentFont.getStyle() + Font.ITALIC, currentFont.getSize() );  	}  	  	public void setColor( String newColor )  	{  		// need to remove the control word "\cf" to get the color number  		newColor = newColor.substring( 3 );  		newColor = newColor.trim();  		currentColor = (Color)colorTable.elementAt( Integer.valueOf(newColor).intValue() );   	}	} // end class RTFReader									 